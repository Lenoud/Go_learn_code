// @FileName : 01并发编程.go
// @Time : 2025/3/21 下午4:32
// @Author : luobozi

package main

// 此处开始编写代码
/*
go语言并发模型 ： MPG
M: machine 系统线程
P: processer 逻辑处理器
G: goroutine go语言协程


通常情况下，每一个运行的处理任务的M 必须要对应着一个P
	运行M和P的关系 1：1
	一个调度器P 对应着一个本地队列 全局G队列
本地队列满了  会把G放到全局队列中去
hand off机制
1.如果发生syscall处理的线程M0陷入阻塞状态，这个M0就会释放P
	p就会转移给空闲的M1去执行，如果没有空闲的M1，就会创建一个新的M1
2.如果系统调用结束，根据M0是否获取到P，将会对原来的G做不同处理
	如果有空闲的P 则获取一个P 继续执行原来的G0
	如果没有空闲的P 将原来的G0 加入到全局队列中，等待被其它的P调度，M0进入缓存池睡眠
全局队列runqueue是各个P在运行完自己的本地的

work stealing机制
本线程没有可运行的G的时候，可以从全局队列中获取G
如果全局队列中也没有，就从别的线程绑定的P哪里偷取一半的G处理

# sysmon协程 不需要p也能执行 做协程监控的
在 go中goroutine最多占用Cpu 10ms 防止其它gorutine饿死
任何超过10ms 的协程都会被抢占 将运行时间留给其他goroutine


#协程抢占
#垃圾回收

*/
